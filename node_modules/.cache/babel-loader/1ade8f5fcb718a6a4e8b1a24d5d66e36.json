{"ast":null,"code":"/*! npm.im/iphone-inline-video 2.2.2 */\nimport { frameIntervalometer } from 'intervalometer';\n\nfunction preventEvent(element, eventName, test) {\n  function handler(e) {\n    if (!test || test(element, eventName)) {\n      e.stopImmediatePropagation(); // // console.log(eventName, 'prevented on', element);\n    }\n  }\n\n  element.addEventListener(eventName, handler); // Return handler to allow to disable the prevention. Usage:\n  // const preventionHandler = preventEvent(el, 'click');\n  // el.removeEventHandler('click', preventionHandler);\n\n  return handler;\n}\n\nfunction proxyProperty(object, propertyName, sourceObject, copyFirst) {\n  function get() {\n    return sourceObject[propertyName];\n  }\n\n  function set(value) {\n    sourceObject[propertyName] = value;\n  }\n\n  if (copyFirst) {\n    set(object[propertyName]);\n  }\n\n  Object.defineProperty(object, propertyName, {\n    get: get,\n    set: set\n  });\n}\n\nfunction proxyEvent(object, eventName, sourceObject) {\n  sourceObject.addEventListener(eventName, function () {\n    return object.dispatchEvent(new Event(eventName));\n  });\n}\n\nfunction dispatchEventAsync(element, type) {\n  Promise.resolve().then(function () {\n    element.dispatchEvent(new Event(type));\n  });\n}\n\nvar iOS8or9 = typeof document === 'object' && 'object-fit' in document.head.style && !matchMedia('(-webkit-video-playable-inline)').matches;\nvar IIV = 'bfred-it:iphone-inline-video';\nvar IIVEvent = 'bfred-it:iphone-inline-video:event';\nvar IIVPlay = 'bfred-it:iphone-inline-video:nativeplay';\nvar IIVPause = 'bfred-it:iphone-inline-video:nativepause';\n/**\n * UTILS\n */\n\nfunction getAudioFromVideo(video) {\n  var audio = new Audio();\n  proxyEvent(video, 'play', audio);\n  proxyEvent(video, 'playing', audio);\n  proxyEvent(video, 'pause', audio);\n  audio.crossOrigin = video.crossOrigin; // 'data:' causes audio.networkState > 0\n  // which then allows to keep <audio> in a resumable playing state\n  // i.e. once you set a real src it will keep playing if it was if .play() was called\n\n  audio.src = video.src || video.currentSrc || 'data:'; // // if (audio.src === 'data:') {\n  //   TODO: wait for video to be selected\n  // // }\n\n  return audio;\n}\n\nvar lastRequests = [];\nvar requestIndex = 0;\nvar lastTimeupdateEvent;\n\nfunction setTime(video, time, rememberOnly) {\n  // Allow one timeupdate event every 200+ ms\n  if ((lastTimeupdateEvent || 0) + 200 < Date.now()) {\n    video[IIVEvent] = true;\n    lastTimeupdateEvent = Date.now();\n  }\n\n  if (!rememberOnly) {\n    video.currentTime = time;\n  }\n\n  lastRequests[++requestIndex % 3] = time * 100 | 0 / 100;\n}\n\nfunction isPlayerEnded(player) {\n  return player.driver.currentTime >= player.video.duration;\n}\n\nfunction update(timeDiff) {\n  var player = this; // // console.log('update', player.video.readyState, player.video.networkState, player.driver.readyState, player.driver.networkState, player.driver.paused);\n\n  if (player.video.readyState >= player.video.HAVE_FUTURE_DATA) {\n    if (!player.hasAudio) {\n      player.driver.currentTime = player.video.currentTime + timeDiff * player.video.playbackRate / 1000;\n\n      if (player.video.loop && isPlayerEnded(player)) {\n        player.driver.currentTime = 0;\n      }\n    }\n\n    setTime(player.video, player.driver.currentTime);\n  } else if (player.video.networkState === player.video.NETWORK_IDLE && player.video.buffered.length === 0) {\n    // This should happen when the source is available but:\n    // - it's potentially playing (.paused === false)\n    // - it's not ready to play\n    // - it's not loading\n    // If it hasAudio, that will be loaded in the 'emptied' handler below\n    player.video.load(); // // console.log('Will load');\n  } // // console.assert(player.video.currentTime === player.driver.currentTime, 'Video not updating!');\n\n\n  if (player.video.ended) {\n    delete player.video[IIVEvent]; // Allow timeupdate event\n\n    player.video.pause(true);\n  }\n}\n/**\n * METHODS\n */\n\n\nfunction play() {\n  // // console.log('play');\n  var video = this;\n  var player = video[IIV]; // If it's fullscreen, use the native player\n\n  if (video.webkitDisplayingFullscreen) {\n    video[IIVPlay]();\n    return;\n  }\n\n  if (player.driver.src !== 'data:' && player.driver.src !== video.src) {\n    // // console.log('src changed on play', video.src);\n    setTime(video, 0, true);\n    player.driver.src = video.src;\n  }\n\n  if (!video.paused) {\n    return;\n  }\n\n  player.paused = false;\n\n  if (video.buffered.length === 0) {\n    // .load() causes the emptied event\n    // the alternative is .play()+.pause() but that triggers play/pause events, even worse\n    // possibly the alternative is preventing this event only once\n    video.load();\n  }\n\n  player.driver.play();\n  player.updater.start();\n\n  if (!player.hasAudio) {\n    dispatchEventAsync(video, 'play');\n\n    if (player.video.readyState >= player.video.HAVE_ENOUGH_DATA) {\n      // // console.log('onplay');\n      dispatchEventAsync(video, 'playing');\n    }\n  }\n}\n\nfunction pause(forceEvents) {\n  // // console.log('pause');\n  var video = this;\n  var player = video[IIV];\n  player.driver.pause();\n  player.updater.stop(); // If it's fullscreen, the developer the native player.pause()\n  // This is at the end of pause() because it also\n  // needs to make sure that the simulation is paused\n\n  if (video.webkitDisplayingFullscreen) {\n    video[IIVPause]();\n  }\n\n  if (player.paused && !forceEvents) {\n    return;\n  }\n\n  player.paused = true;\n\n  if (!player.hasAudio) {\n    dispatchEventAsync(video, 'pause');\n  } // Handle the 'ended' event only if it's not fullscreen\n\n\n  if (video.ended && !video.webkitDisplayingFullscreen) {\n    video[IIVEvent] = true;\n    dispatchEventAsync(video, 'ended');\n  }\n}\n/**\n * SETUP\n */\n\n\nfunction addPlayer(video, hasAudio) {\n  var player = {};\n  video[IIV] = player;\n  player.paused = true; // Track whether 'pause' events have been fired\n\n  player.hasAudio = hasAudio;\n  player.video = video;\n  player.updater = frameIntervalometer(update.bind(player));\n\n  if (hasAudio) {\n    player.driver = getAudioFromVideo(video);\n  } else {\n    video.addEventListener('canplay', function () {\n      if (!video.paused) {\n        // // console.log('oncanplay');\n        dispatchEventAsync(video, 'playing');\n      }\n    });\n    player.driver = {\n      src: video.src || video.currentSrc || 'data:',\n      muted: true,\n      paused: true,\n      pause: function () {\n        player.driver.paused = true;\n      },\n      play: function () {\n        player.driver.paused = false; // Media automatically goes to 0 if .play() is called when it's done\n\n        if (isPlayerEnded(player)) {\n          setTime(video, 0);\n        }\n      },\n\n      get ended() {\n        return isPlayerEnded(player);\n      }\n\n    };\n  } // .load() causes the emptied event\n\n\n  video.addEventListener('emptied', function () {\n    // // console.log('driver src is', player.driver.src);\n    var wasEmpty = !player.driver.src || player.driver.src === 'data:';\n\n    if (player.driver.src && player.driver.src !== video.src) {\n      // // console.log('src changed to', video.src);\n      setTime(video, 0, true);\n      player.driver.src = video.src; // Playing videos will only keep playing if no src was present when .play()’ed\n\n      if (wasEmpty || !hasAudio && video.autoplay) {\n        player.driver.play();\n      } else {\n        player.updater.stop();\n      }\n    }\n  }, false); // Stop programmatic player when OS takes over\n\n  video.addEventListener('webkitbeginfullscreen', function () {\n    if (!video.paused) {\n      // Make sure that the <audio> and the syncer/updater are stopped\n      video.pause(); // Play video natively\n\n      video[IIVPlay]();\n    } else if (hasAudio && player.driver.buffered.length === 0) {\n      // If the first play is native,\n      // the <audio> needs to be buffered manually\n      // so when the fullscreen ends, it can be set to the same current time\n      player.driver.load();\n    }\n  });\n\n  if (hasAudio) {\n    video.addEventListener('webkitendfullscreen', function () {\n      // Sync audio to new video position\n      player.driver.currentTime = video.currentTime; // // console.assert(player.driver.currentTime === video.currentTime, 'Audio not synced');\n    }); // Allow seeking\n\n    video.addEventListener('seeking', function () {\n      if (lastRequests.indexOf(video.currentTime * 100 | 0 / 100) < 0) {\n        // // console.log('User-requested seeking');\n        player.driver.currentTime = video.currentTime;\n      }\n    });\n  }\n}\n\nfunction preventWithPropOrFullscreen(el) {\n  var isAllowed = el[IIVEvent];\n  delete el[IIVEvent];\n  return !el.webkitDisplayingFullscreen && !isAllowed;\n}\n\nfunction overloadAPI(video) {\n  var player = video[IIV];\n  video[IIVPlay] = video.play;\n  video[IIVPause] = video.pause;\n  video.play = play;\n  video.pause = pause;\n  proxyProperty(video, 'paused', player.driver);\n  proxyProperty(video, 'muted', player.driver, true);\n  proxyProperty(video, 'playbackRate', player.driver, true);\n  proxyProperty(video, 'ended', player.driver);\n  proxyProperty(video, 'loop', player.driver, true); // IIV works by seeking 60 times per second.\n  // These events are now useless.\n\n  preventEvent(video, 'seeking', function (el) {\n    return !el.webkitDisplayingFullscreen;\n  });\n  preventEvent(video, 'seeked', function (el) {\n    return !el.webkitDisplayingFullscreen;\n  }); // Limit timeupdate events\n\n  preventEvent(video, 'timeupdate', preventWithPropOrFullscreen); // Prevent occasional native ended events\n\n  preventEvent(video, 'ended', preventWithPropOrFullscreen);\n}\n\nfunction enableInlineVideo(video, opts) {\n  if (opts === void 0) opts = {}; // Stop if already enabled\n\n  if (video[IIV]) {\n    return;\n  } // Allow the user to skip detection\n\n\n  if (!opts.everywhere) {\n    // Only iOS8 and 9 are supported\n    if (!iOS8or9) {\n      return;\n    } // Stop if it's not an allowed device\n\n\n    if (!(opts.iPad || opts.ipad ? /iPhone|iPod|iPad/ : /iPhone|iPod/).test(navigator.userAgent)) {\n      return;\n    }\n  } // Try to pause\n\n\n  video.pause(); // Prevent autoplay.\n  // An non-started autoplaying video can't be .pause()'d\n\n  var willAutoplay = video.autoplay;\n  video.autoplay = false;\n  addPlayer(video, !video.muted);\n  overloadAPI(video);\n  video.classList.add('IIV'); // Autoplay\n\n  if (video.muted && willAutoplay) {\n    video.play();\n    video.addEventListener('playing', function restoreAutoplay() {\n      video.autoplay = true;\n      video.removeEventListener('playing', restoreAutoplay);\n    });\n  }\n\n  if (!/iPhone|iPod|iPad/.test(navigator.platform)) {\n    console.warn('iphone-inline-video is not guaranteed to work in emulated environments');\n  }\n}\n\nexport default enableInlineVideo;","map":{"version":3,"sources":["C:/Users/ASUS/Desktop/react-navbar-dropdown-master/node_modules/iphone-inline-video/dist/iphone-inline-video.es-modules.js"],"names":["frameIntervalometer","preventEvent","element","eventName","test","handler","e","stopImmediatePropagation","addEventListener","proxyProperty","object","propertyName","sourceObject","copyFirst","get","set","value","Object","defineProperty","proxyEvent","dispatchEvent","Event","dispatchEventAsync","type","Promise","resolve","then","iOS8or9","document","head","style","matchMedia","matches","IIV","IIVEvent","IIVPlay","IIVPause","getAudioFromVideo","video","audio","Audio","crossOrigin","src","currentSrc","lastRequests","requestIndex","lastTimeupdateEvent","setTime","time","rememberOnly","Date","now","currentTime","isPlayerEnded","player","driver","duration","update","timeDiff","readyState","HAVE_FUTURE_DATA","hasAudio","playbackRate","loop","networkState","NETWORK_IDLE","buffered","length","load","ended","pause","play","webkitDisplayingFullscreen","paused","updater","start","HAVE_ENOUGH_DATA","forceEvents","stop","addPlayer","bind","muted","wasEmpty","autoplay","indexOf","preventWithPropOrFullscreen","el","isAllowed","overloadAPI","enableInlineVideo","opts","everywhere","iPad","ipad","navigator","userAgent","willAutoplay","classList","add","restoreAutoplay","removeEventListener","platform","console","warn"],"mappings":"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","sourcesContent":["/*! npm.im/iphone-inline-video 2.2.2 */\nimport { frameIntervalometer } from 'intervalometer';\n\nfunction preventEvent(element, eventName, test) {\n\tfunction handler(e) {\n\t\tif (!test || test(element, eventName)) {\n\t\t\te.stopImmediatePropagation();\n\t\t\t// // console.log(eventName, 'prevented on', element);\n\t\t}\n\t}\n\telement.addEventListener(eventName, handler);\n\n\t// Return handler to allow to disable the prevention. Usage:\n\t// const preventionHandler = preventEvent(el, 'click');\n\t// el.removeEventHandler('click', preventionHandler);\n\treturn handler;\n}\n\nfunction proxyProperty(object, propertyName, sourceObject, copyFirst) {\n\tfunction get() {\n\t\treturn sourceObject[propertyName];\n\t}\n\tfunction set(value) {\n\t\tsourceObject[propertyName] = value;\n\t}\n\n\tif (copyFirst) {\n\t\tset(object[propertyName]);\n\t}\n\n\tObject.defineProperty(object, propertyName, {get: get, set: set});\n}\n\nfunction proxyEvent(object, eventName, sourceObject) {\n\tsourceObject.addEventListener(eventName, function () { return object.dispatchEvent(new Event(eventName)); });\n}\n\nfunction dispatchEventAsync(element, type) {\n\tPromise.resolve().then(function () {\n\t\telement.dispatchEvent(new Event(type));\n\t});\n}\n\nvar iOS8or9 = typeof document === 'object' && 'object-fit' in document.head.style && !matchMedia('(-webkit-video-playable-inline)').matches;\n\nvar IIV = 'bfred-it:iphone-inline-video';\nvar IIVEvent = 'bfred-it:iphone-inline-video:event';\nvar IIVPlay = 'bfred-it:iphone-inline-video:nativeplay';\nvar IIVPause = 'bfred-it:iphone-inline-video:nativepause';\n\n/**\n * UTILS\n */\n\nfunction getAudioFromVideo(video) {\n\tvar audio = new Audio();\n\tproxyEvent(video, 'play', audio);\n\tproxyEvent(video, 'playing', audio);\n\tproxyEvent(video, 'pause', audio);\n\taudio.crossOrigin = video.crossOrigin;\n\n\t// 'data:' causes audio.networkState > 0\n\t// which then allows to keep <audio> in a resumable playing state\n\t// i.e. once you set a real src it will keep playing if it was if .play() was called\n\taudio.src = video.src || video.currentSrc || 'data:';\n\n\t// // if (audio.src === 'data:') {\n\t//   TODO: wait for video to be selected\n\t// // }\n\treturn audio;\n}\n\nvar lastRequests = [];\nvar requestIndex = 0;\nvar lastTimeupdateEvent;\n\nfunction setTime(video, time, rememberOnly) {\n\t// Allow one timeupdate event every 200+ ms\n\tif ((lastTimeupdateEvent || 0) + 200 < Date.now()) {\n\t\tvideo[IIVEvent] = true;\n\t\tlastTimeupdateEvent = Date.now();\n\t}\n\tif (!rememberOnly) {\n\t\tvideo.currentTime = time;\n\t}\n\tlastRequests[++requestIndex % 3] = time * 100 | 0 / 100;\n}\n\nfunction isPlayerEnded(player) {\n\treturn player.driver.currentTime >= player.video.duration;\n}\n\nfunction update(timeDiff) {\n\tvar player = this;\n\t// // console.log('update', player.video.readyState, player.video.networkState, player.driver.readyState, player.driver.networkState, player.driver.paused);\n\tif (player.video.readyState >= player.video.HAVE_FUTURE_DATA) {\n\t\tif (!player.hasAudio) {\n\t\t\tplayer.driver.currentTime = player.video.currentTime + ((timeDiff * player.video.playbackRate) / 1000);\n\t\t\tif (player.video.loop && isPlayerEnded(player)) {\n\t\t\t\tplayer.driver.currentTime = 0;\n\t\t\t}\n\t\t}\n\t\tsetTime(player.video, player.driver.currentTime);\n\t} else if (player.video.networkState === player.video.NETWORK_IDLE && player.video.buffered.length === 0) {\n\t\t// This should happen when the source is available but:\n\t\t// - it's potentially playing (.paused === false)\n\t\t// - it's not ready to play\n\t\t// - it's not loading\n\t\t// If it hasAudio, that will be loaded in the 'emptied' handler below\n\t\tplayer.video.load();\n\t\t// // console.log('Will load');\n\t}\n\n\t// // console.assert(player.video.currentTime === player.driver.currentTime, 'Video not updating!');\n\n\tif (player.video.ended) {\n\t\tdelete player.video[IIVEvent]; // Allow timeupdate event\n\t\tplayer.video.pause(true);\n\t}\n}\n\n/**\n * METHODS\n */\n\nfunction play() {\n\t// // console.log('play');\n\tvar video = this;\n\tvar player = video[IIV];\n\n\t// If it's fullscreen, use the native player\n\tif (video.webkitDisplayingFullscreen) {\n\t\tvideo[IIVPlay]();\n\t\treturn;\n\t}\n\n\tif (player.driver.src !== 'data:' && player.driver.src !== video.src) {\n\t\t// // console.log('src changed on play', video.src);\n\t\tsetTime(video, 0, true);\n\t\tplayer.driver.src = video.src;\n\t}\n\n\tif (!video.paused) {\n\t\treturn;\n\t}\n\tplayer.paused = false;\n\n\tif (video.buffered.length === 0) {\n\t\t// .load() causes the emptied event\n\t\t// the alternative is .play()+.pause() but that triggers play/pause events, even worse\n\t\t// possibly the alternative is preventing this event only once\n\t\tvideo.load();\n\t}\n\n\tplayer.driver.play();\n\tplayer.updater.start();\n\n\tif (!player.hasAudio) {\n\t\tdispatchEventAsync(video, 'play');\n\t\tif (player.video.readyState >= player.video.HAVE_ENOUGH_DATA) {\n\t\t\t// // console.log('onplay');\n\t\t\tdispatchEventAsync(video, 'playing');\n\t\t}\n\t}\n}\nfunction pause(forceEvents) {\n\t// // console.log('pause');\n\tvar video = this;\n\tvar player = video[IIV];\n\n\tplayer.driver.pause();\n\tplayer.updater.stop();\n\n\t// If it's fullscreen, the developer the native player.pause()\n\t// This is at the end of pause() because it also\n\t// needs to make sure that the simulation is paused\n\tif (video.webkitDisplayingFullscreen) {\n\t\tvideo[IIVPause]();\n\t}\n\n\tif (player.paused && !forceEvents) {\n\t\treturn;\n\t}\n\n\tplayer.paused = true;\n\tif (!player.hasAudio) {\n\t\tdispatchEventAsync(video, 'pause');\n\t}\n\n\t// Handle the 'ended' event only if it's not fullscreen\n\tif (video.ended && !video.webkitDisplayingFullscreen) {\n\t\tvideo[IIVEvent] = true;\n\t\tdispatchEventAsync(video, 'ended');\n\t}\n}\n\n/**\n * SETUP\n */\n\nfunction addPlayer(video, hasAudio) {\n\tvar player = {};\n\tvideo[IIV] = player;\n\tplayer.paused = true; // Track whether 'pause' events have been fired\n\tplayer.hasAudio = hasAudio;\n\tplayer.video = video;\n\tplayer.updater = frameIntervalometer(update.bind(player));\n\n\tif (hasAudio) {\n\t\tplayer.driver = getAudioFromVideo(video);\n\t} else {\n\t\tvideo.addEventListener('canplay', function () {\n\t\t\tif (!video.paused) {\n\t\t\t\t// // console.log('oncanplay');\n\t\t\t\tdispatchEventAsync(video, 'playing');\n\t\t\t}\n\t\t});\n\t\tplayer.driver = {\n\t\t\tsrc: video.src || video.currentSrc || 'data:',\n\t\t\tmuted: true,\n\t\t\tpaused: true,\n\t\t\tpause: function () {\n\t\t\t\tplayer.driver.paused = true;\n\t\t\t},\n\t\t\tplay: function () {\n\t\t\t\tplayer.driver.paused = false;\n\t\t\t\t// Media automatically goes to 0 if .play() is called when it's done\n\t\t\t\tif (isPlayerEnded(player)) {\n\t\t\t\t\tsetTime(video, 0);\n\t\t\t\t}\n\t\t\t},\n\t\t\tget ended() {\n\t\t\t\treturn isPlayerEnded(player);\n\t\t\t}\n\t\t};\n\t}\n\n\t// .load() causes the emptied event\n\tvideo.addEventListener('emptied', function () {\n\t\t// // console.log('driver src is', player.driver.src);\n\t\tvar wasEmpty = !player.driver.src || player.driver.src === 'data:';\n\t\tif (player.driver.src && player.driver.src !== video.src) {\n\t\t\t// // console.log('src changed to', video.src);\n\t\t\tsetTime(video, 0, true);\n\t\t\tplayer.driver.src = video.src;\n\t\t\t// Playing videos will only keep playing if no src was present when .play()’ed\n\t\t\tif (wasEmpty || (!hasAudio && video.autoplay)) {\n\t\t\t\tplayer.driver.play();\n\t\t\t} else {\n\t\t\t\tplayer.updater.stop();\n\t\t\t}\n\t\t}\n\t}, false);\n\n\t// Stop programmatic player when OS takes over\n\tvideo.addEventListener('webkitbeginfullscreen', function () {\n\t\tif (!video.paused) {\n\t\t\t// Make sure that the <audio> and the syncer/updater are stopped\n\t\t\tvideo.pause();\n\n\t\t\t// Play video natively\n\t\t\tvideo[IIVPlay]();\n\t\t} else if (hasAudio && player.driver.buffered.length === 0) {\n\t\t\t// If the first play is native,\n\t\t\t// the <audio> needs to be buffered manually\n\t\t\t// so when the fullscreen ends, it can be set to the same current time\n\t\t\tplayer.driver.load();\n\t\t}\n\t});\n\tif (hasAudio) {\n\t\tvideo.addEventListener('webkitendfullscreen', function () {\n\t\t\t// Sync audio to new video position\n\t\t\tplayer.driver.currentTime = video.currentTime;\n\t\t\t// // console.assert(player.driver.currentTime === video.currentTime, 'Audio not synced');\n\t\t});\n\n\t\t// Allow seeking\n\t\tvideo.addEventListener('seeking', function () {\n\t\t\tif (lastRequests.indexOf(video.currentTime * 100 | 0 / 100) < 0) {\n\t\t\t\t// // console.log('User-requested seeking');\n\t\t\t\tplayer.driver.currentTime = video.currentTime;\n\t\t\t}\n\t\t});\n\t}\n}\n\nfunction preventWithPropOrFullscreen(el) {\n\tvar isAllowed = el[IIVEvent];\n\tdelete el[IIVEvent];\n\treturn !el.webkitDisplayingFullscreen && !isAllowed;\n}\n\nfunction overloadAPI(video) {\n\tvar player = video[IIV];\n\tvideo[IIVPlay] = video.play;\n\tvideo[IIVPause] = video.pause;\n\tvideo.play = play;\n\tvideo.pause = pause;\n\tproxyProperty(video, 'paused', player.driver);\n\tproxyProperty(video, 'muted', player.driver, true);\n\tproxyProperty(video, 'playbackRate', player.driver, true);\n\tproxyProperty(video, 'ended', player.driver);\n\tproxyProperty(video, 'loop', player.driver, true);\n\n\t// IIV works by seeking 60 times per second.\n\t// These events are now useless.\n\tpreventEvent(video, 'seeking', function (el) { return !el.webkitDisplayingFullscreen; });\n\tpreventEvent(video, 'seeked', function (el) { return !el.webkitDisplayingFullscreen; });\n\n\t// Limit timeupdate events\n\tpreventEvent(video, 'timeupdate', preventWithPropOrFullscreen);\n\n\t// Prevent occasional native ended events\n\tpreventEvent(video, 'ended', preventWithPropOrFullscreen);\n}\n\nfunction enableInlineVideo(video, opts) {\n\tif ( opts === void 0 ) opts = {};\n\n\t// Stop if already enabled\n\tif (video[IIV]) {\n\t\treturn;\n\t}\n\n\t// Allow the user to skip detection\n\tif (!opts.everywhere) {\n\t\t// Only iOS8 and 9 are supported\n\t\tif (!iOS8or9) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Stop if it's not an allowed device\n\t\tif (!(opts.iPad || opts.ipad ? /iPhone|iPod|iPad/ : /iPhone|iPod/).test(navigator.userAgent)) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// Try to pause\n\tvideo.pause();\n\n\t// Prevent autoplay.\n\t// An non-started autoplaying video can't be .pause()'d\n\tvar willAutoplay = video.autoplay;\n\tvideo.autoplay = false;\n\n\taddPlayer(video, !video.muted);\n\toverloadAPI(video);\n\tvideo.classList.add('IIV');\n\n\t// Autoplay\n\tif (video.muted && willAutoplay) {\n\t\tvideo.play();\n\t\tvideo.addEventListener('playing', function restoreAutoplay() {\n\t\t\tvideo.autoplay = true;\n\t\t\tvideo.removeEventListener('playing', restoreAutoplay);\n\t\t});\n\t}\n\n\tif (!/iPhone|iPod|iPad/.test(navigator.platform)) {\n\t\tconsole.warn('iphone-inline-video is not guaranteed to work in emulated environments');\n\t}\n}\n\nexport default enableInlineVideo;\n"]},"metadata":{},"sourceType":"module"}